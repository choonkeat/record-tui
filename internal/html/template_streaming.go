package html

import (
	"html"
)

// StreamingOptions configures streaming HTML rendering.
type StreamingOptions struct {
	Title      string     // Page title (defaults to "Terminal" if empty)
	DataURL    string     // URL to fetch session data from
	FooterLink FooterLink // Optional co-branding link
}

// RenderStreamingPlaybackHTML generates an HTML document that streams terminal data from a URL.
// Unlike RenderPlaybackHTML which embeds all data in the HTML, this version fetches data
// via JavaScript fetch() and streams it to xterm.js for progressive rendering.
// This is ideal for large recordings where embedding would cause slow page loads.
func RenderStreamingPlaybackHTML(opts StreamingOptions) (string, error) {
	// Default title
	title := opts.Title
	if title == "" {
		title = "Terminal"
	}
	escapedTitle := html.EscapeString(title)
	escapedDataURL := html.EscapeString(opts.DataURL)

	// Build footer HTML
	footerHTML := `generated by <a href="https://github.com/choonkeat/record-tui" target="_blank" rel="noopener noreferrer">record-tui</a>`
	if opts.FooterLink.Text != "" && opts.FooterLink.URL != "" {
		footerHTML += ` x <a href="` + html.EscapeString(opts.FooterLink.URL) + `" target="_blank" rel="noopener noreferrer">` + html.EscapeString(opts.FooterLink.Text) + `</a>`
	}

	htmlDoc := `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>` + escapedTitle + `</title>
  <!-- xterm.js CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: auto;
      background-color: #1e1e1e;
      color: #d4d4d4;
      font-family: 'SF Mono', 'Menlo', 'Consolas', 'Monaco', 'Courier New', monospace;
      line-height: 1.4;
    }

    #terminal {
      width: 100%;
      height: auto;
      display: block;
    }

    #loading {
      padding: 24px;
      font-size: 16px;
      color: #888888;
    }

    #footer {
      margin-top: 24px;
      padding: 12px 24px;
      text-align: right;
      font-size: 12px;
      color: #888888;
      border-top: 1px solid rgba(212, 212, 212, 0.1);
    }

    #footer a {
      color: #e0e0e0;
      text-decoration: none;
      transition: color 0.2s;
    }

    #footer a:hover {
      color: #ffffff;
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div id="loading">Loading...</div>
  <div id="terminal"></div>
  <div id="footer">
    ` + footerHTML + `
  </div>

  <!-- xterm.js script -->
  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>

  <script>
    // Data URL to fetch session content from
    const DATA_URL = '` + escapedDataURL + `';

    // ============================================================
    // Streaming cleaner - same logic as internal/js/cleaner.js
    // ============================================================

    // Clear sequence separator - must match Go's ClearSeparator in clear.go:9
    // Using raw UTF-8 bytes for 'â”€' (U+2500) = 0xe2 0x94 0x80
    const CLEAR_SEPARATOR = '\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 terminal cleared \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n';

    // Clear sequence pattern - matches Go's clearPattern in clear.go:16
    const clearPattern = /\x1b\[H\x1b\[[23]J|\x1b\[[23]J\x1b\[H|\x1b\[[23]J/g;

    function stripHeader(text) {
      const lines = text.split('\n');
      let startIndex = 0;
      for (let i = 0; i < lines.length && i < 5; i++) {
        const line = lines[i];
        if (line.startsWith('Script started on') || line.startsWith('Command:')) {
          startIndex = i + 1;
        }
      }
      if (startIndex === 0) return text;
      return lines.slice(startIndex).join('\n');
    }

    function stripFooter(text) {
      const lines = text.split('\n');
      let footerStartIndex = lines.length;
      for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i];
        if (line.includes('Saving session') ||
            line.includes('Command exit status') ||
            line.includes('Script done on') ||
            (line.trim() === '' && i > 0)) {
          footerStartIndex = i;
        } else if (footerStartIndex < lines.length) {
          break;
        }
      }
      let endIndex = footerStartIndex;
      while (endIndex > 0 && lines[endIndex - 1].trim() === '') endIndex--;
      if (endIndex >= lines.length) return text;
      return lines.slice(0, endIndex).join('\n');
    }

    function createStreamingCleaner(onOutput) {
      let headerBuffer = '';
      let headerStripped = false;
      const HEADER_LINES_THRESHOLD = 5;
      let hasEmittedContent = false;
      let pendingSeparator = false;
      let pendingWhitespace = '';
      let escapeBuffer = '';
      let trailingBuffer = '';
      const TRAILING_SIZE = 500;

      function processForClears(text) {
        if (!text) return '';
        clearPattern.lastIndex = 0;
        const matches = [];
        let m;
        while ((m = clearPattern.exec(text)) !== null) {
          matches.push([m.index, m.index + m[0].length]);
        }
        if (matches.length === 0) {
          if (text.trim() !== '') {
            if (pendingSeparator) {
              const result = CLEAR_SEPARATOR + pendingWhitespace + text;
              pendingSeparator = false;
              pendingWhitespace = '';
              hasEmittedContent = true;
              return result;
            }
            hasEmittedContent = true;
            return text;
          }
          if (pendingSeparator) {
            pendingWhitespace += text;
            return '';
          }
          return text;
        }
        let result = '';
        let lastEnd = 0;
        for (const [start, end] of matches) {
          const before = text.slice(lastEnd, start);
          if (before.trim() !== '') {
            if (pendingSeparator) {
              result += CLEAR_SEPARATOR + pendingWhitespace;
              pendingSeparator = false;
              pendingWhitespace = '';
            }
            result += before;
            hasEmittedContent = true;
          } else if (pendingSeparator) {
            pendingWhitespace += before;
          }
          if (hasEmittedContent) {
            pendingSeparator = true;
            pendingWhitespace = '';
          }
          lastEnd = end;
        }
        const remaining = text.slice(lastEnd);
        if (remaining.trim() !== '') {
          if (pendingSeparator) {
            result += CLEAR_SEPARATOR + pendingWhitespace;
            pendingSeparator = false;
            pendingWhitespace = '';
          }
          result += remaining;
          hasEmittedContent = true;
        } else if (remaining && pendingSeparator) {
          pendingWhitespace += remaining;
        }
        return result;
      }

      function write(chunk) {
        let text = escapeBuffer + chunk;
        escapeBuffer = '';
        const lastEsc = text.lastIndexOf('\x1b');
        if (lastEsc >= 0 && lastEsc > text.length - 10) {
          escapeBuffer = text.slice(lastEsc);
          text = text.slice(0, lastEsc);
        }
        if (!headerStripped) {
          headerBuffer += text;
          text = '';
          const newlineCount = (headerBuffer.match(/\n/g) || []).length;
          if (newlineCount >= HEADER_LINES_THRESHOLD) {
            headerBuffer = stripHeader(headerBuffer);
            headerStripped = true;
            text = headerBuffer;
            headerBuffer = '';
          } else {
            return;
          }
        }
        text = trailingBuffer + text;
        trailingBuffer = '';
        if (text.length > TRAILING_SIZE) {
          const toEmit = text.slice(0, -TRAILING_SIZE);
          trailingBuffer = text.slice(-TRAILING_SIZE);
          const processed = processForClears(toEmit);
          if (processed) onOutput(processed);
        } else {
          trailingBuffer = text;
        }
      }

      function end() {
        let text = trailingBuffer + escapeBuffer;
        if (!headerStripped) {
          text = headerBuffer + text;
          text = stripHeader(text);
        }
        text = stripFooter(text);
        const processed = processForClears(text);
        if (processed) onOutput(processed);
      }

      return { write, end };
    }

    /**
     * Stream session data from URL to xterm using streaming cleaner.
     */
    async function streamSession(url, xterm) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error('Failed to fetch ' + url + ': ' + response.status + ' ' + response.statusText);
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      const loadingDiv = document.getElementById('loading');
      let firstWrite = true;

      const cleaner = createStreamingCleaner((chunk) => {
        if (firstWrite) {
          loadingDiv.style.display = 'none';
          firstWrite = false;
        }
        xterm.write(chunk);
      });

      while (true) {
        const result = await reader.read();
        if (result.done) break;
        cleaner.write(decoder.decode(result.value, { stream: true }));
      }
      cleaner.end();
    }

    /**
     * Resize terminal to fit actual content after streaming completes.
     * For playback, we only care about visible content, not cursor position.
     */
    function resizeToFitContent(xterm, cols) {
      const buffer = xterm.buffer.active;
      if (!buffer) return;

      // Find the last row with content
      let lastContentRow = 0;
      for (let i = buffer.length - 1; i >= 0; i--) {
        const line = buffer.getLine(i);
        if (line) {
          const lineStr = line.translateToString(true).trim();
          if (lineStr.length > 0) {
            lastContentRow = i + 1;
            break;
          }
        }
      }

      // Use only content height, not cursor position (cursor may be far below content)
      const actualHeight = Math.max(lastContentRow, 1);

      xterm.resize(cols, actualHeight);
    }

    // Main initialization
    async function main() {
      // Initialize xterm with large defaults (will resize down after streaming)
      // Use 240 cols to match embedded template's max width cap
      const COLS = 240;
      const terminalDiv = document.getElementById('terminal');
      const xterm = new Terminal({
        cols: COLS,
        rows: 1000, // Large initial value, will resize down after streaming
        fontSize: 15,
        cursorBlink: false,
        disableStdin: true,
        theme: {
          background: '#1e1e1e',
          foreground: '#d4d4d4',
        },
        allowProposedApi: true,
      });
      xterm.open(terminalDiv);

      // Remove textarea to prevent focus capture
      const terminalTextarea = document.querySelector('.xterm textarea');
      if (terminalTextarea) {
        terminalTextarea.remove();
      }

      try {
        await streamSession(DATA_URL, xterm);

        // Resize to fit content after streaming completes
        setTimeout(function() {
          resizeToFitContent(xterm, COLS);
        }, 100);
      } catch (err) {
        console.error('Streaming error:', err);
        document.getElementById('loading').textContent = 'Error: ' + err.message;
        document.getElementById('loading').style.display = 'block';
      }
    }

    main();
  </script>
</body>
</html>`

	return htmlDoc, nil
}
