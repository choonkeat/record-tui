package html

import (
	"fmt"
	"html"

	"github.com/choonkeat/record-tui/internal/js"
)

// StreamingOptions configures streaming HTML rendering.
type StreamingOptions struct {
	Title      string     // Page title (defaults to "Terminal" if empty)
	DataURL    string     // URL to fetch session data from
	FooterLink FooterLink // Optional co-branding link
	Cols       uint16     // Terminal columns (0 = auto-detect, default 240)
	MaxRows    uint32     // Maximum initial rows before auto-resize (0 = default 100000)
}

// RenderStreamingPlaybackHTML generates an HTML document that streams terminal data from a URL.
// Unlike RenderPlaybackHTML which embeds all data in the HTML, this version fetches data
// via JavaScript fetch() and streams it to xterm.js for progressive rendering.
// This is ideal for large recordings where embedding would cause slow page loads.
func RenderStreamingPlaybackHTML(opts StreamingOptions) (string, error) {
	// Default title
	title := opts.Title
	if title == "" {
		title = "Terminal"
	}
	escapedTitle := html.EscapeString(title)
	escapedDataURL := html.EscapeString(opts.DataURL)

	// Terminal dimensions (0 = auto-detect)
	cols := opts.Cols
	if cols == 0 {
		cols = 240 // Default to match embedded template's max width cap
	}

	// Use large initial viewport with no scrollback
	// Post-render resize will shrink to actual content size
	// This avoids clipping issues with progressive writes and resize
	rows := opts.MaxRows
	if rows == 0 {
		rows = 100000 // Default if not specified
	}
	scrollback := uint32(0)
	autoResizeEnabled := true

	// Build footer HTML
	footerHTML := `generated by <a href="https://github.com/choonkeat/record-tui" target="_blank" rel="noopener noreferrer">record-tui</a>`
	if opts.FooterLink.Text != "" && opts.FooterLink.URL != "" {
		footerHTML += ` x <a href="` + html.EscapeString(opts.FooterLink.URL) + `" target="_blank" rel="noopener noreferrer">` + html.EscapeString(opts.FooterLink.Text) + `</a>`
	}

	htmlDoc := `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>` + escapedTitle + `</title>
  <!-- xterm.js CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.css" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: auto;
      background-color: #1e1e1e;
      color: #d4d4d4;
      font-family: 'SF Mono', 'Menlo', 'Consolas', 'Monaco', 'Courier New', monospace;
      line-height: 1.4;
    }

    #terminal {
      width: 100%;
      height: auto;
      display: block;
    }

    #loading {
      padding: 24px;
      font-size: 16px;
      color: #888888;
    }

    #footer {
      margin-top: 24px;
      padding: 12px 24px;
      text-align: right;
      font-size: 12px;
      color: #888888;
      border-top: 1px solid rgba(212, 212, 212, 0.1);
    }

    #footer a {
      color: #e0e0e0;
      text-decoration: none;
      transition: color 0.2s;
    }

    #footer a:hover {
      color: #ffffff;
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div id="loading">Loading...</div>
  <div id="terminal"></div>
  <div id="footer">
    ` + footerHTML + `
  </div>

  <!-- xterm.js script -->
  <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.js"></script>

  <script>
    // Data URL to fetch session content from
    const DATA_URL = '` + escapedDataURL + `';
    // Terminal dimensions (from server metadata or defaults)
    const TERM_COLS = ` + fmt.Sprintf("%d", cols) + `;
    const TERM_ROWS = ` + fmt.Sprintf("%d", rows) + `;
    const TERM_SCROLLBACK = ` + fmt.Sprintf("%d", scrollback) + `;
    const AUTO_RESIZE = ` + fmt.Sprintf("%t", autoResizeEnabled) + `;

    // ============================================================
    // Streaming cleaner - embedded from internal/js/cleaner-core.js
    // This is the single source of truth for both Node.js and browser
    // ============================================================
` + js.CleanerCoreJS + `

    /**
     * Fetch session data and write to xterm all at once (like embedded).
     * This avoids progressive write issues with resize.
     */
    async function streamSession(url, xterm) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error('Failed to fetch ' + url + ': ' + response.status + ' ' + response.statusText);
      }

      const loadingDiv = document.getElementById('loading');

      // Collect all content first
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let allContent = '';

      const cleaner = createStreamingCleaner((chunk) => {
        allContent += chunk;
      });

      while (true) {
        const result = await reader.read();
        if (result.done) break;
        cleaner.write(decoder.decode(result.value, { stream: true }));
      }
      cleaner.end();

      // Write all content at once (like embedded template does)
      loadingDiv.style.display = 'none';
      xterm.write(allContent);
    }

    // Main initialization
    async function main() {
      // Initialize xterm with dimensions from server metadata (or defaults for auto-detect)
      // Read-only terminal: no keyboard/mouse input, but selection allowed for copy
      const terminalDiv = document.getElementById('terminal');
      const xterm = new Terminal({
        cols: TERM_COLS,
        rows: TERM_ROWS,
        scrollback: TERM_SCROLLBACK,
        fontSize: 15,
        cursorBlink: false,
        disableStdin: true,
        altClickMovesCursor: false,
        scrollOnUserInput: false,
        theme: {
          background: '#1e1e1e',
          foreground: '#d4d4d4',
        },
        allowProposedApi: true,
      });
      xterm.open(terminalDiv);

      // Block keyboard input but allow copy shortcut to pass through to browser
      xterm.attachCustomKeyEventHandler((event) => {
        // Allow Cmd+C / Ctrl+C to be handled by browser's native copy
        if ((event.metaKey || event.ctrlKey) && event.key === 'c') {
          return true;
        }
        return false; // Block all other keys from xterm processing
      });

      // Intercept copy events to trim trailing whitespace from each line
      document.addEventListener('copy', (event) => {
        const selection = xterm.getSelection();
        if (selection) {
          const cleaned = selection.split('\n').map(line => line.trimEnd()).join('\n');
          event.clipboardData.setData('text/plain', cleaned);
          event.preventDefault();
        }
      });

      // Block wheel events - let the page scroll instead of terminal
      xterm.attachCustomWheelEventHandler(() => false);

      try {
        await streamSession(DATA_URL, xterm);

        // Resize to fit actual content (grow or shrink)
        if (AUTO_RESIZE) {
          setTimeout(function() {
            const buffer = xterm.buffer.active;
            if (!buffer) return;

            // Find last row with content
            let lastContentRow = 1;
            for (let i = buffer.length - 1; i >= 0; i--) {
              const line = buffer.getLine(i);
              if (line && line.translateToString(true).trim()) {
                lastContentRow = i + 1;
                break;
              }
            }

            // Account for cursor position too
            const cursorRow = buffer.cursorY + 1;
            const actualHeight = Math.max(lastContentRow, cursorRow, 1);

            // Resize down to actual content height
            if (actualHeight < TERM_ROWS) {
              xterm.resize(TERM_COLS, actualHeight);
            }

            // Scroll to top and reset page position
            xterm.scrollToTop();
            window.scrollTo(0, 0);
          }, 100);
        }
      } catch (err) {
        console.error('Streaming error:', err);
        document.getElementById('loading').textContent = 'Error: ' + err.message;
        document.getElementById('loading').style.display = 'block';
      }
    }

    main();
  </script>
</body>
</html>`

	return htmlDoc, nil
}
