package html

import (
	"html"
)

// StreamingOptions configures streaming HTML rendering.
type StreamingOptions struct {
	Title      string     // Page title (defaults to "Terminal" if empty)
	DataURL    string     // URL to fetch session data from
	FooterLink FooterLink // Optional co-branding link
}

// RenderStreamingPlaybackHTML generates an HTML document that streams terminal data from a URL.
// Unlike RenderPlaybackHTML which embeds all data in the HTML, this version fetches data
// via JavaScript fetch() and streams it to xterm.js for progressive rendering.
// This is ideal for large recordings where embedding would cause slow page loads.
func RenderStreamingPlaybackHTML(opts StreamingOptions) (string, error) {
	// Default title
	title := opts.Title
	if title == "" {
		title = "Terminal"
	}
	escapedTitle := html.EscapeString(title)
	escapedDataURL := html.EscapeString(opts.DataURL)

	// Build footer HTML
	footerHTML := `generated by <a href="https://github.com/choonkeat/record-tui" target="_blank" rel="noopener noreferrer">record-tui</a>`
	if opts.FooterLink.Text != "" && opts.FooterLink.URL != "" {
		footerHTML += ` x <a href="` + html.EscapeString(opts.FooterLink.URL) + `" target="_blank" rel="noopener noreferrer">` + html.EscapeString(opts.FooterLink.Text) + `</a>`
	}

	htmlDoc := `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>` + escapedTitle + `</title>
  <!-- xterm.js CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: auto;
      background-color: #1e1e1e;
      color: #d4d4d4;
      font-family: 'SF Mono', 'Menlo', 'Consolas', 'Monaco', 'Courier New', monospace;
      line-height: 1.4;
    }

    #terminal {
      width: 100%;
      height: auto;
      display: block;
    }

    #loading {
      padding: 24px;
      font-size: 16px;
      color: #888888;
    }

    #footer {
      margin-top: 24px;
      padding: 12px 24px;
      text-align: right;
      font-size: 12px;
      color: #888888;
      border-top: 1px solid rgba(212, 212, 212, 0.1);
    }

    #footer a {
      color: #e0e0e0;
      text-decoration: none;
      transition: color 0.2s;
    }

    #footer a:hover {
      color: #ffffff;
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div id="loading">Loading...</div>
  <div id="terminal"></div>
  <div id="footer">
    ` + footerHTML + `
  </div>

  <!-- xterm.js script -->
  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>

  <script>
    // Data URL to fetch session content from
    const DATA_URL = '` + escapedDataURL + `';

    // Clear sequence separator (matches Go implementation in internal/session/clear.go)
    const CLEAR_SEPARATOR = '\n\n──────── terminal cleared ────────\n\n';

    // Clear sequence pattern (matches Go implementation)
    // Matches: \x1b[H\x1b[2J, \x1b[H\x1b[3J, \x1b[2J\x1b[H, \x1b[3J\x1b[H, \x1b[2J, \x1b[3J
    const clearPattern = /\x1b\[H\x1b\[[23]J|\x1b\[[23]J\x1b\[H|\x1b\[[23]J/g;

    /**
     * Strip header lines from session content.
     * Matches Go's StripMetadata in internal/session/cleaner.go:
     * removes first ~5 lines starting with "Script started on" or "Command:"
     */
    function stripHeader(text) {
      const lines = text.split('\n');
      let startIndex = 0;

      // Find where actual content starts (skip header)
      for (let i = 0; i < lines.length && i < 5; i++) {
        const line = lines[i];
        if (line.startsWith('Script started on') || line.startsWith('Command:')) {
          startIndex = i + 1;
        }
      }

      if (startIndex === 0) {
        return text; // No header found
      }

      return lines.slice(startIndex).join('\n');
    }

    /**
     * Strip footer lines from session content.
     * Matches Go's StripMetadata in internal/session/cleaner.go:
     * removes trailing lines containing "Saving session", "Script done on", "Command exit status"
     */
    function stripFooter(text) {
      const lines = text.split('\n');
      let endIndex = lines.length;

      // Find where actual content ends (skip footer)
      // Work backwards from end
      let footerStartIndex = lines.length;
      for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i];
        if (line.includes('Saving session') ||
            line.includes('Command exit status') ||
            line.includes('Script done on') ||
            line.trim() === '') {
          footerStartIndex = i;
        } else if (footerStartIndex < lines.length) {
          // Found content before footer, stop
          break;
        }
      }
      endIndex = footerStartIndex;

      // Trim trailing empty lines
      while (endIndex > 0 && lines[endIndex - 1].trim() === '') {
        endIndex--;
      }

      if (endIndex >= lines.length) {
        return text; // No footer found
      }

      return lines.slice(0, endIndex).join('\n');
    }

    /**
     * Neutralize clear sequences by replacing them with visible separator.
     * Matches Go's NeutralizeClearSequences in internal/session/clear.go.
     */
    function neutralizeClearSequences(text) {
      return text.replace(clearPattern, CLEAR_SEPARATOR);
    }

    /**
     * Stream session data from URL to xterm.
     * Handles header/footer stripping and clear sequence neutralization
     * while streaming for progressive rendering.
     *
     * Design notes:
     * - Uses trailing buffer (500 bytes) to handle footer detection without
     *   prematurely writing footer content to terminal
     * - Avoids splitting ANSI escape sequences by checking for incomplete
     *   sequences at chunk boundaries (escape sequences start with \x1b)
     */
    async function streamSession(url, xterm) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error('Failed to fetch ' + url + ': ' + response.status + ' ' + response.statusText);
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      let buffer = '';
      let headerStripped = false;
      let firstWrite = true;
      const TRAILING_SIZE = 500; // Buffer for footer detection

      // Hide loading indicator on first write
      const loadingDiv = document.getElementById('loading');

      while (true) {
        const result = await reader.read();
        if (result.done) break;

        buffer += decoder.decode(result.value, { stream: true });

        // Strip header once we have enough content
        if (!headerStripped && buffer.includes('\n')) {
          buffer = stripHeader(buffer);
          headerStripped = true;
        }

        // Keep trailing buffer for footer detection, write the rest
        if (buffer.length > TRAILING_SIZE) {
          let toWrite = buffer.slice(0, -TRAILING_SIZE);
          buffer = buffer.slice(-TRAILING_SIZE);

          // Don't split escape sequences - find last \x1b
          const lastEsc = toWrite.lastIndexOf('\x1b');
          if (lastEsc > toWrite.length - 10 && lastEsc >= 0) {
            buffer = toWrite.slice(lastEsc) + buffer;
            toWrite = toWrite.slice(0, lastEsc);
          }

          if (toWrite) {
            // Hide loading on first write
            if (firstWrite) {
              loadingDiv.style.display = 'none';
              firstWrite = false;
            }
            xterm.write(neutralizeClearSequences(toWrite));
          }
        }
      }

      // Final: strip footer, neutralize remaining buffer, write
      const finalContent = neutralizeClearSequences(stripFooter(buffer));
      if (finalContent) {
        if (firstWrite) {
          loadingDiv.style.display = 'none';
        }
        xterm.write(finalContent);
      }
    }

    /**
     * Resize terminal to fit actual content after streaming completes.
     */
    function resizeToFitContent(xterm, cols) {
      const buffer = xterm.buffer.active;
      if (!buffer) return;

      // Find the last row with content
      let lastContentRow = 0;
      for (let i = buffer.length - 1; i >= 0; i--) {
        const line = buffer.getLine(i);
        if (line) {
          const lineStr = line.translateToString(true).trim();
          if (lineStr.length > 0) {
            lastContentRow = i + 1;
            break;
          }
        }
      }

      // Account for cursor position
      const cursorRow = buffer.cursorY + 1;
      const actualHeight = Math.max(lastContentRow, cursorRow, 1);

      xterm.resize(cols, actualHeight);
    }

    // Main initialization
    async function main() {
      // Initialize xterm with reasonable defaults
      const terminalDiv = document.getElementById('terminal');
      const xterm = new Terminal({
        cols: 120,
        rows: 50,
        fontSize: 15,
        cursorBlink: false,
        disableStdin: true,
        theme: {
          background: '#1e1e1e',
          foreground: '#d4d4d4',
        },
        allowProposedApi: true,
      });
      xterm.open(terminalDiv);

      // Remove textarea to prevent focus capture
      const terminalTextarea = document.querySelector('.xterm textarea');
      if (terminalTextarea) {
        terminalTextarea.remove();
      }

      try {
        await streamSession(DATA_URL, xterm);

        // Resize to fit content after streaming completes
        setTimeout(function() {
          resizeToFitContent(xterm, 120);
        }, 100);
      } catch (err) {
        console.error('Streaming error:', err);
        document.getElementById('loading').textContent = 'Error: ' + err.message;
        document.getElementById('loading').style.display = 'block';
      }
    }

    main();
  </script>
</body>
</html>`

	return htmlDoc, nil
}
