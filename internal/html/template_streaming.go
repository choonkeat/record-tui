package html

import (
	"fmt"
	"html"

	"github.com/choonkeat/record-tui/internal/js"
)

// StreamingOptions configures streaming HTML rendering.
type StreamingOptions struct {
	Title         string     // Page title (defaults to "Terminal" if empty)
	DataURL       string     // URL to fetch session data from
	FooterLink    FooterLink // Optional co-branding link
	Cols          uint16     // Terminal columns (0 = auto-detect, default 240)
	Rows          uint16     // Terminal rows (0 = auto-detect via post-render resize)
	EstimatedRows uint32     // Content-based row estimate from caller (0 = use scrollback buffer)
}

// RenderStreamingPlaybackHTML generates an HTML document that streams terminal data from a URL.
// Unlike RenderPlaybackHTML which embeds all data in the HTML, this version fetches data
// via JavaScript fetch() and streams it to xterm.js for progressive rendering.
// This is ideal for large recordings where embedding would cause slow page loads.
func RenderStreamingPlaybackHTML(opts StreamingOptions) (string, error) {
	// Default title
	title := opts.Title
	if title == "" {
		title = "Terminal"
	}
	escapedTitle := html.EscapeString(title)
	escapedDataURL := html.EscapeString(opts.DataURL)

	// Terminal dimensions (0 = auto-detect)
	cols := opts.Cols
	if cols == 0 {
		cols = 240 // Default to match embedded template's max width cap
	}

	// Determine rows - use EstimatedRows if provided, otherwise large default
	var rows uint32
	if opts.EstimatedRows > 0 {
		rows = opts.EstimatedRows
	} else if opts.Rows > 0 {
		rows = uint32(opts.Rows)
	} else {
		rows = 1000
	}

	// Always use large scrollback buffer and auto-resize as safety measure
	// This ensures full scroll history even if EstimatedRows is slightly off
	const scrollback uint32 = 1000000
	const autoResizeEnabled = true

	// Build footer HTML
	footerHTML := `generated by <a href="https://github.com/choonkeat/record-tui" target="_blank" rel="noopener noreferrer">record-tui</a>`
	if opts.FooterLink.Text != "" && opts.FooterLink.URL != "" {
		footerHTML += ` x <a href="` + html.EscapeString(opts.FooterLink.URL) + `" target="_blank" rel="noopener noreferrer">` + html.EscapeString(opts.FooterLink.Text) + `</a>`
	}

	htmlDoc := `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>` + escapedTitle + `</title>
  <!-- xterm.js CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.css" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: auto;
      background-color: #1e1e1e;
      color: #d4d4d4;
      font-family: 'SF Mono', 'Menlo', 'Consolas', 'Monaco', 'Courier New', monospace;
      line-height: 1.4;
    }

    #terminal {
      width: 100%;
      height: auto;
      display: block;
    }

    #loading {
      padding: 24px;
      font-size: 16px;
      color: #888888;
    }

    #footer {
      margin-top: 24px;
      padding: 12px 24px;
      text-align: right;
      font-size: 12px;
      color: #888888;
      border-top: 1px solid rgba(212, 212, 212, 0.1);
    }

    #footer a {
      color: #e0e0e0;
      text-decoration: none;
      transition: color 0.2s;
    }

    #footer a:hover {
      color: #ffffff;
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div id="loading">Loading...</div>
  <div id="terminal"></div>
  <div id="footer">
    ` + footerHTML + `
  </div>

  <!-- xterm.js script -->
  <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.js"></script>

  <script>
    // Data URL to fetch session content from
    const DATA_URL = '` + escapedDataURL + `';
    // Terminal dimensions (from server metadata or defaults)
    const TERM_COLS = ` + fmt.Sprintf("%d", cols) + `;
    const TERM_ROWS = ` + fmt.Sprintf("%d", rows) + `;
    const TERM_SCROLLBACK = ` + fmt.Sprintf("%d", scrollback) + `;
    const AUTO_RESIZE = ` + fmt.Sprintf("%t", autoResizeEnabled) + `;

    // ============================================================
    // Streaming cleaner - embedded from internal/js/cleaner-core.js
    // This is the single source of truth for both Node.js and browser
    // ============================================================
` + js.CleanerCoreJS + `

    /**
     * Stream session data from URL to xterm using streaming cleaner.
     */
    async function streamSession(url, xterm) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error('Failed to fetch ' + url + ': ' + response.status + ' ' + response.statusText);
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      const loadingDiv = document.getElementById('loading');
      let firstWrite = true;

      const cleaner = createStreamingCleaner((chunk) => {
        if (firstWrite) {
          loadingDiv.style.display = 'none';
          firstWrite = false;
        }
        xterm.write(chunk);
      });

      while (true) {
        const result = await reader.read();
        if (result.done) break;
        cleaner.write(decoder.decode(result.value, { stream: true }));
      }
      cleaner.end();
    }

    /**
     * Resize terminal to fit actual content after streaming completes.
     * For playback, we only care about visible content, not cursor position.
     */
    function resizeToFitContent(xterm, cols) {
      const buffer = xterm.buffer.active;
      if (!buffer) return;

      // Find the last row with content
      let lastContentRow = 0;
      for (let i = buffer.length - 1; i >= 0; i--) {
        const line = buffer.getLine(i);
        if (line) {
          const lineStr = line.translateToString(true).trim();
          if (lineStr.length > 0) {
            lastContentRow = i + 1;
            break;
          }
        }
      }

      // Use only content height, not cursor position (cursor may be far below content)
      const actualHeight = Math.max(lastContentRow, 1);

      xterm.resize(cols, actualHeight);
    }

    // Main initialization
    async function main() {
      // Initialize xterm with dimensions from server metadata (or defaults for auto-detect)
      // Read-only terminal: no keyboard/mouse input, but selection allowed for copy
      const terminalDiv = document.getElementById('terminal');
      const xterm = new Terminal({
        cols: TERM_COLS,
        rows: TERM_ROWS,
        scrollback: TERM_SCROLLBACK,
        fontSize: 15,
        cursorBlink: false,
        disableStdin: true,
        altClickMovesCursor: false,
        scrollOnUserInput: false,
        theme: {
          background: '#1e1e1e',
          foreground: '#d4d4d4',
        },
        allowProposedApi: true,
      });
      xterm.open(terminalDiv);

      // Block keyboard input but allow copy shortcut to pass through to browser
      xterm.attachCustomKeyEventHandler((event) => {
        // Allow Cmd+C / Ctrl+C to be handled by browser's native copy
        if ((event.metaKey || event.ctrlKey) && event.key === 'c') {
          return true;
        }
        return false; // Block all other keys from xterm processing
      });

      // Block wheel events - let the page scroll instead of terminal
      xterm.attachCustomWheelEventHandler(() => false);

      try {
        await streamSession(DATA_URL, xterm);

        // Only resize if in auto-detect mode (no dimensions provided by server)
        if (AUTO_RESIZE) {
          setTimeout(function() {
            resizeToFitContent(xterm, TERM_COLS);
          }, 100);
        }
      } catch (err) {
        console.error('Streaming error:', err);
        document.getElementById('loading').textContent = 'Error: ' + err.message;
        document.getElementById('loading').style.display = 'block';
      }
    }

    main();
  </script>
</body>
</html>`

	return htmlDoc, nil
}
