package html

import (
	"encoding/base64"
	"encoding/json"
	"html"
)

// RenderPlaybackHTML generates HTML document with terminal display.
// Encodes frames as base64 to embed directly in the HTML.
// Title is used for the page title (defaults to "Terminal" if empty).
// FooterLink optionally adds a co-branding link (e.g., "generated by record-tui x swe-swe").
func RenderPlaybackHTML(frames []PlaybackFrame, title string, footerLink FooterLink) (string, error) {
	// Encode frames as base64 to avoid escaping issues
	framesJSON, err := json.Marshal(frames)
	if err != nil {
		return "", err
	}

	framesBase64 := base64.StdEncoding.EncodeToString(framesJSON)

	// Default title
	if title == "" {
		title = "Terminal"
	}
	escapedTitle := html.EscapeString(title)

	// Build footer HTML
	footerHTML := `generated by <a href="https://github.com/choonkeat/record-tui" target="_blank" rel="noopener noreferrer">record-tui</a>`
	if footerLink.Text != "" && footerLink.URL != "" {
		footerHTML += ` x <a href="` + html.EscapeString(footerLink.URL) + `" target="_blank" rel="noopener noreferrer">` + html.EscapeString(footerLink.Text) + `</a>`
	}

	htmlDoc := `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>` + escapedTitle + `</title>
  <!-- xterm.js CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.css" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: auto;
      background-color: #1e1e1e;
      color: #d4d4d4;
      font-family: 'SF Mono', 'Menlo', 'Consolas', 'Monaco', 'Courier New', monospace;
      line-height: 1.4;
    }

    #terminal {
      width: 100%;
      height: auto;
      display: block;
    }

    #footer {
      margin-top: 24px;
      padding: 12px 24px;
      text-align: right;
      font-size: 12px;
      color: #888888;
      border-top: 1px solid rgba(212, 212, 212, 0.1);
    }

    #footer a {
      color: #e0e0e0;
      text-decoration: none;
      transition: color 0.2s;
    }

    #footer a:hover {
      color: #ffffff;
      text-decoration: underline;
    }

    #loading {
      padding: 24px;
      font-size: 16px;
      color: #888888;
    }
  </style>
</head>
<body>
  <div id="loading">Loading...</div>
  <div id="terminal"></div>
  <div id="footer">
    ` + footerHTML + `
  </div>

  <!-- xterm.js script -->
  <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.js"></script>

  <script>
    // Decode base64-encoded frame data (UTF-8 safe)
    const framesBase64 = '` + framesBase64 + `';
    const framesJson = new TextDecoder().decode(
      Uint8Array.from(atob(framesBase64), c => c.charCodeAt(0))
    );
    const frames = JSON.parse(framesJson);

    // Get content to calculate dimensions (use last frame which has all content)
    const content = frames.length > 0 ? frames[frames.length - 1].content : '(No frames to display)';

    // Parse ANSI escape sequences to find actual cursor positions used
    // Look for cursor positioning sequences like ESC[row;colH
    let maxUsedRow = 1;
    const cursorPositionRegex = /\x1b\[([0-9]+);([0-9]+)H/g;
    let match;
    while ((match = cursorPositionRegex.exec(content)) !== null) {
      const row = parseInt(match[1], 10);
      if (row > 0) {
        maxUsedRow = Math.max(maxUsedRow, row);
      }
    }
    // Also count newlines as a fallback minimum height
    const lineCount = content.split('\n').length;
    const estimatedRows = Math.max(maxUsedRow, lineCount, 24);

    // Estimate cols from content
    const normalized = content.split('\r\n').join('\n').split('\r').join('\n');
    let lines = normalized.split('\n');
    let maxLineLength = 0;
    for (const line of lines) {
      maxLineLength = Math.max(maxLineLength, line.length);
    }
    // Use max of 240 to avoid excessively wide terminals
    const contentCols = Math.min(Math.max(maxLineLength, 80), 240);

    // Initialize xterm.js with dimensions based on actual content usage
    // Read-only terminal: no keyboard/mouse input, but selection allowed for copy
    const terminalDiv = document.getElementById('terminal');
    const xterm = new Terminal({
      cols: contentCols,
      rows: estimatedRows,
      fontSize: 15,
      cursorBlink: false,
      disableStdin: true,
      altClickMovesCursor: false,
      scrollOnUserInput: false,
      theme: {
        background: '#1e1e1e',
        foreground: '#d4d4d4',
      },
      allowProposedApi: true,
    });
    xterm.open(terminalDiv);

    // Block keyboard events; handle copy shortcut (Cmd+C / Ctrl+C) via Clipboard API
    xterm.attachCustomKeyEventHandler((event) => {
      if ((event.metaKey || event.ctrlKey) && event.key === 'c' && event.type === 'keydown') {
        const selection = xterm.getSelection();
        if (selection) {
          navigator.clipboard.writeText(selection);
        }
      }
      return false; // Block all keys from xterm processing
    });

    // Block wheel events - let the page scroll instead of terminal
    xterm.attachCustomWheelEventHandler(() => false);

    // Disable textarea to prevent focus capture and soft keyboard
    const terminalTextarea = document.querySelector('.xterm textarea');
    if (terminalTextarea) {
      terminalTextarea.setAttribute('disabled', 'true');
    }

    // Hide loading indicator and display content
    document.getElementById('loading').style.display = 'none';
    xterm.write(content);

    // After rendering, check actual rendered height and resize if needed
    // This handles cases where TUI positioning might have created empty rows
    setTimeout(() => {
      const buffer = xterm.buffer.active;
      if (!buffer) return;

      // Find the last row that has any non-whitespace content
      let lastContentRow = 0;
      const bufferLength = buffer.length;
      for (let i = bufferLength - 1; i >= 0; i--) {
        const line = buffer.getLine(i);
        if (line) {
          const lineStr = line.translateToString(true).trim();
          if (lineStr.length > 0) {
            lastContentRow = i + 1;
            break;
          }
        }
      }

      // Account for cursor position too
      const cursorRow = buffer.cursorY + 1;
      const actualHeight = Math.max(lastContentRow, cursorRow, 1);

      // Only resize if we found less content than allocated
      if (actualHeight < estimatedRows) {
        xterm.resize(contentCols, actualHeight);
      }
    }, 0);
  </script>
</body>
</html>`

	return htmlDoc, nil
}
